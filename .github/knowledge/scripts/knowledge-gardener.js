/**
 * Knowledge Gardener
 * 
 * This script maintains the integrity of the knowledge base by:
 * 1. Scanning all Markdown files in .github/knowledge/
 * 2. Extracting metadata (status, related_files, last_verified)
 * 3. Checking if related code files have been modified since the last verification
 * 4. Generating a central index (00_INDEX.md) with health status
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Configuration
const KNOWLEDGE_DIR = path.join(__dirname, '..'); // .github/knowledge
const INDEX_FILE = path.join(KNOWLEDGE_DIR, '00_INDEX.md');
const ROOT_DIR = path.resolve(path.join(__dirname, '../../..')); // Project root

// Helper: Get all MD files recursively
function getMdFiles(dir, fileList = []) {
    const files = fs.readdirSync(dir);
    files.forEach(file => {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);
        if (stat.isDirectory()) {
            if (file !== 'scripts') { // Skip scripts dir itself if it contains md
                getMdFiles(filePath, fileList);
            }
        } else {
            if (path.extname(file) === '.md' && file !== '00_INDEX.md') {
                fileList.push(filePath);
            }
        }
    });
    return fileList;
}

// Helper: Parse Frontmatter (simple regex)
function parseFrontmatter(content) {
    const match = content.match(/^---\n([\s\S]*?)\n---/);
    if (!match) return null;
    
    const metadata = {};
    const lines = match[1].split('\n');
    
    lines.forEach(line => {
        const parts = line.split(':');
        if (parts.length >= 2) {
            const key = parts[0].trim();
            let value = parts.slice(1).join(':').trim();
            
            // Handle array format [item1, item2]
            if (value.startsWith('[') && value.endsWith(']')) {
                value = value.substring(1, value.length - 1).split(',').map(s => s.trim());
            }
            metadata[key] = value;
        }
    });
    
    return metadata;
}

// Helper: Get last modification date for a file (System time)
function getLastModifiedDate(filePath) {
    try {
        const stats = fs.statSync(filePath);
        return stats.mtime;
    } catch (err) {
        return null; // File doesn't exist
    }
}

// Main execution
console.log('ğŸŒ± Knowledge Gardener starting...');
console.log(`ğŸ“‚ Scanning: ${KNOWLEDGE_DIR}`);

const mdFiles = getMdFiles(KNOWLEDGE_DIR);
const knowledgeUnits = [];

mdFiles.forEach(file => {
    const content = fs.readFileSync(file, 'utf8');
    const meta = parseFrontmatter(content);
    
    const relativePath = path.relative(KNOWLEDGE_DIR, file);
    
    const unit = {
        file: relativePath,
        status: 'Unknown',
        lastVerified: null,
        outdated: false,
        reason: ''
    };

    if (meta) {
        unit.status = meta.status || 'Unknown';
        
        if (meta.last_verified) {
            unit.lastVerified = new Date(meta.last_verified);
            
            // Check related files
            if (meta.related_files) {
                const relatedFiles = Array.isArray(meta.related_files) ? meta.related_files : [meta.related_files];
                
                for (const related of relatedFiles) {
                    // Resolve related file path relative to project root
                    const relatedPath = path.resolve(ROOT_DIR, related);
                    const lastModified = getLastModifiedDate(relatedPath);
                    
                    if (lastModified && unit.lastVerified < lastModified) {
                        unit.outdated = true;
                        unit.reason = `Related file ${related} changed on ${lastModified.toISOString().split('T')[0]}`;
                        break;
                    }
                }
            }
        }
    }
    
    knowledgeUnits.push(unit);
});

// Generate Index Content
let indexContent = `# ğŸ§  Knowledge Base Index\n\n`;
indexContent += `*Auto-generated by Knowledge Gardener on ${new Date().toISOString()}*\n\n`;
indexContent += `| Status | Knowledge Unit | Last Verified | Health |\n`;
indexContent += `| :---: | --- | --- | :---: |\n`;

knowledgeUnits.forEach(unit => {
    const statusIcon = unit.status === 'Stable' ? 'ğŸŸ¢' : unit.status === 'Draft' ? 'ğŸŸ¡' : 'âšª';
    let healthIcon = 'âœ…';
    
    if (unit.outdated) {
        healthIcon = 'âš ï¸ **Outdated**';
    } else if (!unit.lastVerified) {
        healthIcon = 'â“ Unverified';
    }
    
    const lastVerifiedStr = unit.lastVerified ? unit.lastVerified.toISOString().split('T')[0] : 'N/A';
    const fileLink = `[${unit.file}](${unit.file})`;
    
    indexContent += `| ${statusIcon} | ${fileLink} | ${lastVerifiedStr} | ${healthIcon} |\n`;
});

indexContent += `\n\n## ğŸ›¡ï¸ Legend\n`;
indexContent += `- ğŸŸ¢ Stable: Validated and reliable knowledge.\n`;
indexContent += `- ğŸŸ¡ Draft: Work in progress.\n`;
indexContent += `- âš ï¸ Outdated: Linked code has been modified locally since last verification. Needs review.\n`;
indexContent += `- âœ… Healthy: Up to date with codebase.\n`;

fs.writeFileSync(INDEX_FILE, indexContent);

console.log(`âœ… Index generated at: ${INDEX_FILE}`);
console.log(`ğŸ“Š Processed ${knowledgeUnits.length} knowledge units.`);
